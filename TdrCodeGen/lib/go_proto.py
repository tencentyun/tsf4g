
#@ block: go_file
{{c_render_block('file_head', 0, _context_)}}
{{c_render_block('common_code', 0, _context_)}}
#@ endblock

#@ block: file_head
% import datetime
% create_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
// auto generated by tdr {{tdrversion}}, don't edit!
% for line in godoc.splitlines():
// {{line}}
% end
// create time: {{create_time}}
% pkgname = get('pkgname')
package {{pkgname}}
#@ endblock

#@ block: common_code
import (
    "encoding/binary"
    "errors"
    "io"

    "git.woa.com/tsf4g/tdrcom"
)
#@ endblock

#@ block: struct_code
{{c_render_block('struct_head', 0, _context_)}}
{{c_render_block('struct_var_def', 0, _context_)}}
{{c_render_block('struct_end', 0, _context_)}}
{{c_render_block('struct_new_func', 0, _context_)}}
{{c_render_block('struct_get_base_version_func', 0, _context_)}}
{{c_render_block('struct_get_current_version_func', 0, _context_)}}
{{c_render_block('tdr_db_field_func', 0, _context_)}}
{{c_render_block('struct_init_func', 0, _context_)}}
{{c_render_block('struct_pack_func', 0, _context_)}}
{{c_render_block('struct_packto_func', 0, _context_)}}
{{c_render_block('struct_unpack_func', 0, _context_)}}
{{c_render_block('struct_unpackfrom_func', 0, _context_)}}
#@ endblock

#@ block: struct_head
% sname = c_get_struct_name(name)
const (
    {{c_get_base_version_name(sname)}} uint32 = {{base_version}}
    {{c_get_current_version_name(sname)}} uint32 = {{version}}
    % for fld in filter(lambda f:f.version > base_version, fields):
    {{c_get_struct_field_version_name(sname, fld.name)}} uint32 = {{fld.version}}
    % end
)

% if splittablekey or primarykey or index_column_map:
var {{sname}}DBFeilds = &tdrcom.TDRDBFeilds{
    % if splittablekey:
    SplittableKey: "{{c_convert_to_title(splittablekey)}}",
    % end
    % if primarykey:
    PrimaryKey: "{{c_convert_to_title(primarykey)}}",
    % end
    % if index_column_map:
    Index2Column: map[string]string{
        % for index, column in index_column_map.items():
            "{{c_get_struct_name(index)}}": "{{c_convert_to_title(column)}}",
        % end
    },
    % end
}
% end

// {{sname}}
type {{sname}} struct {
#@ endblock

#@ block: struct_var_def
% for fld in fields:
    % fname = c_get_struct_field_name(fld.name)
    % ftype = c_get_type_name(fld.type)
    % ftag = '`tdr_field:"%s"' % fld.name

    % if fld.count:
        % ftag += ' tdr_count:"' + fld.count + '"'
    % end

    % if fld.refer:
        % ftag += ' tdr_refer:"' + c_convert_to_title(fld.refer) + '"'
    % end

    % if fld.select:
        % ftag += ' tdr_select:"' + c_convert_to_title(fld.select) + '"'
    % end

    % ftag += '`'
    % if fld.count and int(fld.count) > 1:
        % if c_is_complex_type(fld.typeid):
{{fname}} []*{{ftype}} {{ftag}}
        % else:
{{fname}} []{{c_convert_to_go_type(fld.typeid)}} {{ftag}}
        % end
    % else:
        % if c_is_complex_type(fld.typeid):
{{fname}} *{{ftype}} {{ftag}}
        % else:
{{fname}} {{c_convert_to_go_type(fld.typeid)}} {{ftag}}
        % end
    % end
% end
#@ endblock

#@ block: struct_end
}
#@ endblock

#@ block: tdr_db_field_func
% if splittablekey or primarykey or index_column_map:
    % sname = c_get_struct_name(name)
func (this *{{sname}}) GetTDRDBFeilds() *tdrcom.TDRDBFeilds{
    return {{sname}}DBFeilds
}
% end
#@ endblock

#@ block: struct_new_func
% sname = c_get_struct_name(name)
func New{{sname}}() *{{sname}} {
    obj := new({{sname}})
    obj.Init()
    return obj
}
#@ endblock

#@ block: struct_get_base_version_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) GetBaseVersion() uint32 {
    return {{c_get_base_version_name(sname)}}
}
#@ endblock

#@ block: struct_get_current_version_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) GetCurrentVersion() uint32 {
    return {{c_get_current_version_name(sname)}}
}
#@ endblock

#@ block: struct_init_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) Init() {
% for fld in fields:
{{!c_render_block('init_field', 4, fld, only_init=False)}}
% end
}
#@ endblock

#@ block: init_field
% fname = c_get_struct_field_name(name)
% ftype = c_get_type_name(type)
% fselect = c_convert_to_title(select)
% if not count or int(count) == 1:
    % if defaultvalue:
        % if typedef.typeid == TYPE_DATE:
this.{{fname}} = tdrcom.DateToUint("{{defaultvalue}}")
        % elif typedef.typeid == TYPE_TIME:
this.{{fname}} = tdrcom.TimeToUint("{{defaultvalue}}")
        % elif typedef.typeid == TYPE_DATETIME:
this.{{fname}} = tdrcom.DatetimeToUint64("{{defaultvalue}}")
        % elif typedef.typeid == TYPE_IP:
this.{{fname}} = tdrcom.IpToUint("{{defaultvalue}}")
        % elif typedef.typeid == TYPE_STRING:
this.{{fname}} = "{{defaultvalue}}"
        % elif c_is_base_type(typedef.typeid):
this.{{fname}} = {{defaultvalue}}
        % end
    % elif typedef.typeid == TYPE_STRUCT:
        % if only_init:
this.{{fname}}.Init()
        % else:
this.{{fname}} = New{{ftype}}()
        % end
    % elif typedef.typeid == TYPE_UNION:
        % if only_init:
this.{{fname}}.Init(int64(this.{{fselect}}))
        % else:
this.{{fname}} = New{{ftype}}(int64(this.{{fselect}}))
        % end
    % end
% end
#@ endblock

#@ block: struct_pack_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) Pack(cutVer uint32) ([]byte, error) {
    w := tdrcom.NewWriter()
    if err := this.PackTo(cutVer, w); err != nil {
        return nil, errors.New("{{sname}} Pack error\n" + err.Error())
    } else {
        return w.Bytes(), nil
    }
}
#@ endblock

#@ block: struct_packto_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) PackTo(cutVer uint32, w *tdrcom.Writer) error {
    // adjust cut version
    if cutVer == 0 || cutVer > {{c_get_current_version_name(sname)}} {
        cutVer = {{c_get_current_version_name(sname)}}
    }
    // check cut version
    if cutVer < {{c_get_base_version_name(sname)}} {
        return errors.New("{{sname}} cut version must large than {{c_get_base_version_name(name)}}\n")
    }
    % if versionindicator:
    // versionindicator
    this.{{c_convert_to_title(versionindicator)}} = {{c_convert_to_go_type(get_field(versionindicator).typeid)}}(cutVer)
    % end

    % if sizeinfo or any(fld.sizeinfo for fld in fields):
    beginPos := w.Tell()
    % end

    var err error
    % for fld in fields:
        % curr_indent = 4
		% if fld.version > base_version:
            % curr_indent += 4
    if (cutVer >= {{c_get_struct_field_version_name(sname, fld.name)}}) {
		% end
    {{c_render_block('struct_packto_func_per_field', curr_indent, _context_, fld=fld)}}
        % if fld.version > base_version:
    }
        % end
    % end

    % if sizeinfo:
    // sizeinfo
    endPos := w.Tell()
    w.Seek(beginPos+{{get_field_offset(sizeinfo)}}, io.SeekStart)
    err = binary.Write(w, binary.BigEndian, {{c_convert_to_go_type(get_field(sizeinfo).typeid)}}(endPos-beginPos))
    if err != nil {
        return errors.New("{{sname}}'s sizeinfo {{c_convert_to_title(sizeinfo)}} pack error\n" + err.Error())
    }
    w.Seek(endPos, io.SeekStart)
    % end

    return nil
}
#@ endblock

#@ block: struct_packto_func_per_field
% sname = c_get_struct_name(name)
% fname = c_get_struct_field_name(fld.name)
% frefer = c_convert_to_title(fld.refer)
% if fld.sizeinfo:
{{fname}}BeginPos := w.Tell()
% end

% if fld.count and int(fld.count) > 1:
    % if fld.refer:
if this.{{frefer}} < 0 {
    return errors.New("{{sname}}.{{fname}}'s refer {{frefer}} should >= 0")
}
if this.{{frefer}} > {{fld.count}} {
    return errors.New("{{sname}}.{{fname}}'s refer {{frefer}} should <= count {{fld.count}}")
}
if len(this.{{fname}}) < int(this.{{frefer}}) {
    return errors.New("{{sname}}.{{fname}}'s length should > {{frefer}}")
}
if this.{{frefer}} > 0 {
        % if not c_is_base_type(fld.typeid):
    for i := 0; i < int(this.{{frefer}}); i++ {
            % if fld.typeid == TYPE_STRING:
    {{c_render_block('struct_pack_string', 4, fld, struct_name=sname, fld_idx=True)}}
            % elif fld.typeid == TYPE_STRUCT:
    {{c_render_block('struct_pack_struct', 4, fld, struct_name=sname, fld_idx=True)}}
            % elif fld.typeid == TYPE_UNION:
    {{c_render_block('struct_pack_union', 4, fld, struct_name=sname, fld_idx=True)}}
            % end
    }
        % else:
    refer{{c_convert_to_title(fname)}} := this.{{fname}}[:this.{{frefer}}]
    err = binary.Write(w, binary.BigEndian, refer{{c_convert_to_title(fname)}})
    if err != nil {
        return errors.New("{{sname}}.{{fname}} pack error\n" + err.Error())
    }
        % end
}
    % else:
if len(this.{{fname}}) != int({{fld.count}}) {
    return errors.New("{{sname}}.{{fname}}'s length should = {{fld.count}}")
}
        % if not c_is_base_type(fld.typeid):
for i := 0; i < int({{fld.count}}); i++ {
            % if fld.typeid == TYPE_STRING:
    {{c_render_block('struct_pack_string', 4, fld, struct_name=sname, fld_idx=True)}}
            % elif fld.typeid == TYPE_STRUCT:
    {{c_render_block('struct_pack_struct', 4, fld, struct_name=sname, fld_idx=True)}}
            % elif fld.typeid == TYPE_UNION:
    {{c_render_block('struct_pack_union', 4, fld, struct_name=sname, fld_idx=True)}}
            % end
}
        % else:
{{c_render_block('struct_pack_base_array', 0, fld, struct_name=sname)}}
        % end
    % end
% else:
    % curr_indent = 0
    % if fld.refer:
        % curr_indent = 4
if this.{{frefer}} != 0 && this.{{frefer}} != 1 {
    return errors.New("{{sname}}.{{fname}} is not array, this.{{frefer}} should be 0 or 1")
}
if this.{{frefer}} == 1 {
    % end
    % if c_is_base_type(fld.typeid):
{{c_render_block('struct_pack_base', curr_indent, fld, struct_name=sname)}}
    % elif fld.typeid == TYPE_STRING:
{{c_render_block('struct_pack_string', curr_indent, fld, struct_name=sname, fld_idx=False)}}
    % elif fld.typeid == TYPE_STRUCT:
{{c_render_block('struct_pack_struct', curr_indent, fld, struct_name=sname, fld_idx=False)}}
    % elif fld.typeid == TYPE_UNION:
{{c_render_block('struct_pack_union', curr_indent, fld, struct_name=sname, fld_idx=False)}}
    % end
    % if fld.refer:
}
    % end
% end

% if fld.sizeinfo:
{{fname}}EndPos := w.Tell()
w.Seek(beginPos+{{get_field_offset(fld.sizeinfo)}}, io.SeekStart)
err = binary.Write(w, binary.BigEndian, {{c_convert_to_go_type(get_field(fld.sizeinfo).typeid)}}({{fname}}EndPos-{{fname}}BeginPos))
if err != nil {
    return errors.New("{{fname}}'s sizeinfo {{fld.sizeinfo}} pack error\n" + err.Error())
}
w.Seek({{fname}}EndPos, io.SeekStart)
% end

#@ endblock

#@ block: struct_pack_base
% fname = c_get_struct_field_name(name)
err = binary.Write(w, binary.BigEndian, this.{{fname}})
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} pack error\n" + err.Error())
}
#@ endblock

#@ block: struct_pack_base_array
% fname = c_get_struct_field_name(name)
err = binary.Write(w, binary.BigEndian, this.{{fname}}[:])
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} pack error\n" + err.Error())
}
#@ endblock

#@ block: struct_pack_string
% fname = c_get_struct_field_name(name)
% if fld_idx:
err = binary.Write(w, binary.BigEndian, uint32(len(this.{{fname}}[i]))+1)
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} string size pack error\n" + err.Error())
}
err = binary.Write(w, binary.BigEndian, append([]byte(this.{{fname}}[i]), 0))
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} string content pack error\n" + err.Error())
}
% else:
err = binary.Write(w, binary.BigEndian, uint32(len(this.{{fname}}))+1)
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} string size pack error\n" + err.Error())
}
err = binary.Write(w, binary.BigEndian, append([]byte(this.{{fname}}), 0))
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} string content pack error\n" + err.Error())
}
% end
#@ endblock

#@ block: struct_pack_struct
% fname = c_get_struct_field_name(name)
% if fld_idx:
err = this.{{fname}}[i].PackTo(cutVer, w)
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} pack error\n" + err.Error())
}
% else:
err = this.{{fname}}.PackTo(cutVer, w)
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} pack error\n" + err.Error())
}
% end
#@ endblock

#@ block: struct_pack_union
% fname = c_get_struct_field_name(name)
% fselect = c_convert_to_title(select)
% if fld_idx:
err = this.{{fname}}[i].PackTo(cutVer, w, int64(this.{{fselect}}))
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} pack error\n" + err.Error())
}
% else:
err = this.{{fname}}.PackTo(cutVer, w, int64(this.{{fselect}}))
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} pack error\n" + err.Error())
}
% end
#@ endblock

#@ block: struct_unpack_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) Unpack(cutVer uint32, data []byte) error {
	if nil == data {
		return errors.New("{{sname}} data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data))
}
#@ endblock

#@ block: struct_unpackfrom_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) UnpackFrom(cutVer uint32, r *tdrcom.Reader) error {
    var err error = nil
% if versionindicator:
    // get net version
    var netVer {{c_convert_to_go_type(get_field(versionindicator).typeid)}}
    oriPos := r.Tell()
    r.Seek(oriPos+{{get_field_offset(versionindicator)}}, io.SeekStart)
    err = binary.Read(r, binary.BigEndian, &netVer)
    if err != nil {
        return errors.New("{{sname}} get net version error\n" + err.Error())
    }
    r.Seek(oriPos, io.SeekStart)
    cutVer = uint32(netVer)
    // check version
    if cutVer < {{c_get_base_version_name(sname)}} || cutVer > {{c_get_current_version_name(sname)}} {
        return errors.New("{{sname}} wrong cut version")
    }
% else:
    // adjust version
    if cutVer == 0 || cutVer > {{c_get_current_version_name(sname)}} {
        cutVer = {{c_get_current_version_name(sname)}}
    }
    // check version
    if cutVer < {{c_get_base_version_name(sname)}} {
        errors.New("{{sname}} cut version must large than {{c_get_base_version_name(sname)}}\n")
    }
% end

% for fld in fields:
    % fname = c_get_struct_field_name(fld.name)
    % curr_indent = 4
    % if fld.version > base_version:
        % curr_indent += 4
    if (cutVer >= {{c_get_struct_field_version_name(name, fname)}}) {
    % end

    {{c_render_block('struct_unpackfrom_func_per_field', curr_indent, _context_, fld=fld)}}

    % if fld.version > base_version:
        % if fld.typeid == TYPE_STRUCT or fld.defaultvalue:
    } else {
        {{!c_render_block('init_field', curr_indent, fld, only_init=True)}}
    }
        % else:
    }
        % end
    % end
% end
    return err
}
#@ endblock

#@ block: struct_unpackfrom_func_per_field
% sname = c_get_struct_name(name)
% fname = c_get_struct_field_name(fld.name)
% frefer = c_convert_to_title(fld.refer)
% fselect = c_convert_to_title(fld.select)
% if fld.count and int(fld.count) > 1:
    % if fld.refer:
if this.{{frefer}} < 0 {
    return errors.New("{{sname}}.{{fname}}'s refer {{frefer}} should >= 0")
}
if this.{{frefer}} > {{fld.count}} {
    return errors.New("{{sname}}.{{fname}}'s refer {{frefer}} should <= count {{fld.count}}")
}
    % end

if this.{{fname}} == nil {
    % ftype = c_get_type_name(fld.type)
    % if c_is_complex_type(fld.typeid):
        % if fld.refer:
    this.{{fname}} = make([]*{{ftype}}, int(this.{{frefer}}))
    for i := 0; i < int(this.{{frefer}}); i++ {
        % else:
    this.{{fname}} = make([]*{{ftype}}, int({{fld.count}}))
    for i := 0; i < int({{fld.count}}); i++ {
        % end
            % if fld.typeid == TYPE_STRUCT:
        this.{{fname}}[i] = New{{ftype}}()
            % else:
        this.{{fname}}[i] = New{{ftype}}(int64(this.{{fselect}}))
            % end
    }
    % else:
        % if fld.refer:
    this.{{fname}} = make([]{{c_convert_to_go_type(fld.typeid)}}, int(this.{{frefer}}))
        % else:
    this.{{fname}} = make([]{{c_convert_to_go_type(fld.typeid)}}, int({{fld.count}}))
        % end
    % end
}

    % if not c_is_base_type(fld.typeid):
        % if fld.refer:
for i := 0; i < int(this.{{frefer}}); i++ {
        % else:
for i := 0; i < int({{fld.count}}); i++ {
        % end
        % if fld.typeid == TYPE_STRING:
{{c_render_block('struct_unpack_string', 4, fld, struct_name=sname, fld_idx=True)}}
        % elif fld.typeid == TYPE_STRUCT:
{{c_render_block('struct_unpack_struct', 4, fld, struct_name=sname, fld_idx=True)}}
        % elif fld.typeid == TYPE_UNION:
{{c_render_block('struct_unpack_union', 4, fld, struct_name=sname, fld_idx=True)}}
        % end
}
    % else:
        % if fld.refer:
refer{{fname}} := this.{{fname}}[:this.{{frefer}}]
err = binary.Read(r, binary.BigEndian, refer{{fname}})
if err != nil {
    return errors.New("{{sname}}.{{fname}} pack error\n" + err.Error())
}
        % else:
{{c_render_block('struct_unpack_base_array', 0, fld, struct_name=sname)}}
        % end
    % end
% else:
    % curr_indent = 0
    % if fld.refer:
        % curr_indent = 4
if this.{{frefer}} != 0 && this.{{frefer}} != 1 {
    return errors.New("{{sname}}.{{fname}} is not array, this.{{frefer}} should be 0 or 1")
}
if this.{{frefer}} == 1{
    % end
    % if c_is_base_type(fld.typeid):
{{c_render_block('struct_unpack_base', curr_indent, fld, struct_name=sname)}}
    % elif fld.typeid == TYPE_STRING:
{{c_render_block('struct_unpack_string', curr_indent, fld, struct_name=sname, fld_idx=False)}}
    % elif fld.typeid == TYPE_STRUCT:
{{c_render_block('struct_unpack_struct', curr_indent, fld, struct_name=sname, fld_idx=False)}}
    % elif fld.typeid == TYPE_UNION:
{{c_render_block('struct_unpack_union', curr_indent, fld, struct_name=sname, fld_idx=False)}}
    % end
    % if fld.refer:
}
    % end
% end
#@ endblock

#@ block: struct_unpack_base
% fname = c_get_struct_field_name(name)
err = binary.Read(r, binary.BigEndian, &this.{{fname}})
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} unpack error\n" + err.Error())
}
#@ endblock

#@ block: struct_unpack_base_array
% fname = c_get_struct_field_name(name)
err = binary.Read(r, binary.BigEndian, this.{{fname}}[:])
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} unpack error\n" + err.Error())
}
#@ endblock

#@ block: struct_unpack_string
% fname = c_get_struct_field_name(name)
var {{name}}Size uint32
err = binary.Read(r, binary.BigEndian, &{{name}}Size)
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} string size unpack error\n" + err.Error())
}

{{name}}Bytes := make([]byte, {{name}}Size)
err = binary.Read(r, binary.BigEndian, {{name}}Bytes)
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} string content unpack error\n" + err.Error())
}
% if fld_idx:
this.{{fname}}[i] = string({{name}}Bytes[:len({{name}}Bytes)-1])
% else:
this.{{fname}} = string({{name}}Bytes[:len({{name}}Bytes)-1])
% end
#@ endblock

#@ block: struct_unpack_struct
% fname = c_get_struct_field_name(name)
% if fld_idx:
err = this.{{fname}}[i].UnpackFrom(cutVer, r)
% else:
err = this.{{fname}}.UnpackFrom(cutVer, r)
% end
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} unpack error\n" + err.Error())
}
#@ endblock

#@ block: struct_unpack_union
% fname = c_get_struct_field_name(name)
% fselect = c_convert_to_title(select)
% if fld_idx:
err = this.{{fname}}[i].UnpackFrom(cutVer, r, int64(this.{{fselect}}))
% else:
err = this.{{fname}}.UnpackFrom(cutVer, r, int64(this.{{fselect}}))
% end
if err != nil {
    return errors.New("{{struct_name}}.{{fname}} unpack error\n" + err.Error())
}
#@ endblock

#@ block: union_code
{{c_render_block('struct_head', 0, _context_)}}
{{c_render_block('struct_var_def', 0, _context_)}}
{{c_render_block('struct_end', 0, _context_)}}
{{c_render_block('union_new_func', 0, _context_)}}
{{c_render_block('struct_get_base_version_func', 0, _context_)}}
{{c_render_block('struct_get_current_version_func', 0, _context_)}}
{{c_render_block('union_init_func', 0, _context_)}}
{{c_render_block('union_pack_func', 0, _context_)}}
{{c_render_block('union_packto_func', 0, _context_)}}
{{c_render_block('union_unpack_func', 0, _context_)}}
{{c_render_block('union_unpackfrom_func', 0, _context_)}}
#@ endblock

#@ block: union_new_func
% sname = c_get_struct_name(name)
func New{{sname}}(selector int64) *{{sname}} {
    obj := new({{sname}})
    obj.Init(selector)
    return obj
}
#@ endblock

#@ block: union_init_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) Init(selector int64) {
    switch(selector) {
% for fld in fields:
    case {{c_convert_to_title(fld.id)}}:
{{!c_render_block('init_field', 4, fld, only_init=False)}}
% end
    }
}
#@ endblock

#@ block: union_pack_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) Pack(cutVer uint32, selector int64) ([]byte, error) {
	w := tdrcom.NewWriter()
	err := this.PackTo(cutVer, w, selector)
	if err != nil {
		return nil, err
	} else {
		return w.Bytes(), nil
	}
}
#@ endblock

#@ block: union_packto_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) PackTo(cutVer uint32, w *tdrcom.Writer, selector int64) error {
	// adjust cut version
    if cutVer == 0 || cutVer > {{c_get_current_version_name(sname)}} {
        cutVer = {{c_get_current_version_name(sname)}}
    }
    // check cut version
    if cutVer < {{c_get_base_version_name(sname)}} {
        return errors.New("{{sname}} cut version must large than {{c_get_base_version_name(name)}}\n")
    }

    var err error = nil
    switch selector {
% for fld in fields:
    % fname = c_get_struct_field_name(fld.name)
    case {{c_convert_to_title(fld.id)}}:
    % if fld.typeid == TYPE_STRUCT:
        if this.{{fname}} == nil {
            return errors.New("{{sname}}.{{fname}} is nil")
        }
    % end
    % curr_indent = 8
    % if fld.version > base_version:
        % curr_indent += 4
        if (cutVer >= {{c_get_struct_field_version_name(sname, fname)}}) {
    % end
{{c_render_block('struct_packto_func_per_field', curr_indent, _context_, fld=fld)}}
    % if fld.version > base_version:
        }
    % end
% end
    }

	return nil
}
#@ endblock

#@ block: union_unpack_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) Unpack(cutVer uint32, data []byte, selector int64) error {
	if nil == data {
		return errors.New("{{sname}} data is nil")
	}
	return this.UnpackFrom(cutVer, tdrcom.NewReader(data), selector)
}
#@ endblock

#@ block: union_unpackfrom_func
% sname = c_get_struct_name(name)
func (this *{{sname}}) UnpackFrom(cutVer uint32, r *tdrcom.Reader, selector int64) error {
    var err error = nil
    // adjust version
    if cutVer == 0 || cutVer > {{c_get_current_version_name(sname)}} {
        cutVer = {{c_get_current_version_name(sname)}}
    }
    // check version
    if cutVer < {{c_get_base_version_name(sname)}} {
        errors.New("{{sname}} cut version must large than {{c_get_base_version_name(name)}}\n")
    }

    switch selector {
% for fld in fields:
    % fname = c_get_struct_field_name(fld.name)
    case {{c_convert_to_title(fld.id)}}:
    % if fld.typeid == TYPE_STRUCT:
        % ftype = c_get_type_name(fld.type)
        if this.{{fname}} == nil {
            this.{{fname}} = New{{ftype}}()
        }
    % end
    % curr_indent = 8
    % if fld.version > base_version:
        % curr_indent += 4
        if (cutVer >= {{c_get_struct_field_version_name(sname, fname)}}) {
    % end

        {{c_render_block('struct_unpackfrom_func_per_field', curr_indent, _context_, fld=fld)}}

    % if fld.version > base_version:
        % if fld.typeid == TYPE_STRUCT or fld.defaultvalue:
        } else {
            {{!c_render_block('init_field', curr_indent, fld, only_init=True)}}
        }
        % else:
        }
        % end
    % end
% end
    }

    return err
}
#@ endblock

#@ block: macro
% sname = c_get_struct_name(name)
% if desc:
// {{desc}}
% end
const {{sname}} int64 = {{value}}
#@ endblock

#@ block: pkg_to_string
func (this *PkgHead) String()  string {
    RetStr := "[head]\n"

    RetStr += "  "
    RetStr += "magic="
    RetStr += strconv.FormatInt(int64(this.Magic), 10)
    RetStr += "\n"

    RetStr += "  "
    RetStr += "version="
    RetStr += strconv.FormatInt(int64(this.Version), 10)
    RetStr += "\n"

    RetStr += "  "
    RetStr += "time="
    RetStr += time.Unix(int64(this.Time), 0).String()
    RetStr += "\n"

    RetStr += "  "
    RetStr += "cmd="
    RetStr += strconv.FormatInt(int64(this.Cmd), 10)
    RetStr += "\n"

    RetStr += "  "
    RetStr += "bodylen="
    RetStr += strconv.FormatInt(int64(this.Bodylen), 10)
    RetStr += "\n"

    RetStr += "  "
    RetStr += "msgid="
    RetStr += strconv.FormatInt(int64(this.Msgid), 10)
    RetStr += "\n"
    return RetStr
}

func (this *PkgBody) String()  string {
    RetStr := "[body]\n"
    PkgBodyType := reflect.TypeOf(*this)
    PkgBodyValue := reflect.ValueOf(*this)

    kd := PkgBodyValue.Kind()
    if kd != reflect.Struct {
        RetStr = "parameter not struct\n"
        return RetStr
    }

    PkgBodyNum := PkgBodyValue.NumField()

    for i := 0; i < PkgBodyNum; i++ {
        if PkgBodyValue.Field(i).IsNil() {
            continue
        }

        RetStr += "  ["
        RetStr += PkgBodyType.Field(i).Name
        RetStr += "]\n"

        RetStr += "    "
        RetStr += fmt.Sprintf("%#v\n", PkgBodyValue.Field(i))
        break
    }

    return RetStr
}
#@ endblock
